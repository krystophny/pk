#!/bin/sh
# pk - minimal package manager for LFS
# Git-like architecture: dispatches to pk-<command> scripts

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
# Check pk.d in script dir first, then /usr/lib/pk for system install
if [ -d "$SCRIPT_DIR/pk.d" ]; then
    PK_LIBEXEC="$SCRIPT_DIR/pk.d"
else
    PK_LIBEXEC="/usr/lib/pk"
fi

usage() {
    cat <<EOF
pk - minimal package manager (v0.0.2)

Usage: pk <command> [args]

Package commands:
  i, install <pkg.tar.xz>  Install package archive
  r, remove <pkgname>      Remove installed package
  l, list                  List installed packages
  q, query <pkgname>       Query package info
  f, files <pkgname>       List package files

Build commands:
  b, build <pkgname>       Build package from package definitions
  d, download <pkgname>    Download package source
  bs, build-stage <N>      Build all packages in stage N

System commands:
  c, check [dirs...]       Check for untracked files
  v, version               Show version

Environment:
  PK_ROOT         Target root (default: / or chroot)
  PK_FORCE_ROOT   Set to 1 to allow installing to host root
EOF
}

[ $# -ge 1 ] || { usage; exit 1; }

cmd="$1"
shift

# Map short commands to full names
case "$cmd" in
    i) cmd="install" ;;
    r) cmd="remove" ;;
    l) cmd="list" ;;
    q) cmd="query" ;;
    f) cmd="files" ;;
    b) cmd="build" ;;
    d) cmd="download" ;;
    bs) cmd="build-stage" ;;
    c) cmd="check" ;;
    v) cmd="version" ;;
    -h|--help|help) usage; exit 0 ;;
esac

# Find and execute subcommand
subcmd="$PK_LIBEXEC/pk-$cmd"

if [ -x "$subcmd" ]; then
    exec "$subcmd" "$@"
elif [ "$cmd" = "version" ]; then
    . "$PK_LIBEXEC/pk-common"
    echo "pk $VERSION"
else
    echo "pk: unknown command '$cmd'" >&2
    echo "Run 'pk help' for usage." >&2
    exit 1
fi
