# LFS Build Configuration
# Only flags with measurable impact: -O3 and LTO

# =============================================================================
# CPU Detection and Parallelism
# =============================================================================

NPROC=$(nproc)
MAKEFLAGS="-j${NPROC}"
NINJA_STATUS="[%f/%t] "

# =============================================================================
# Optimization Flags (only what matters)
# =============================================================================

# -O3: measurable improvement
# LTO: 5-15% for many workloads
# Everything else: noise within measurement error

ARCH_FLAGS="-march=native -mtune=native"
LTO_FLAGS="-flto=${NPROC} -fuse-linker-plugin"

# =============================================================================
# Combined Flag Sets
# =============================================================================

# Standard build: -O3 + LTO
CFLAGS_PERF="-O3 ${ARCH_FLAGS} -pipe ${LTO_FLAGS}"
CXXFLAGS_PERF="${CFLAGS_PERF}"

# Same as PERF (no fast-math anywhere - it breaks things)
CFLAGS_SAFE="${CFLAGS_PERF}"
CXXFLAGS_SAFE="${CFLAGS_SAFE}"

# For toolchain bootstrap (conservative, no LTO)
CFLAGS_BOOTSTRAP="-O2 ${ARCH_FLAGS} -pipe"
CXXFLAGS_BOOTSTRAP="${CFLAGS_BOOTSTRAP}"

# =============================================================================
# Linker Flags
# =============================================================================

LDFLAGS_BASE="-Wl,-O2 -Wl,--as-needed"
LDFLAGS_LTO="${LTO_FLAGS}"
LDFLAGS_PERF="${LDFLAGS_BASE} ${LDFLAGS_LTO}"

# =============================================================================
# Package-Specific Overrides
# =============================================================================

# GCC bootstrap
GCC_BOOTSTRAP_FLAGS="-O2 -pipe"

# glibc: no LTO (ABI stability)
GLIBC_CFLAGS="-O3 ${ARCH_FLAGS} -pipe"

# Kernel uses its own system
KERNEL_MAKE_FLAGS="KCFLAGS='-march=native -mtune=native' KCPPFLAGS='-march=native -mtune=native'"

# Python: -fno-semantic-interposition has measurable import speedup
PYTHON_CFLAGS="${CFLAGS_SAFE} -fno-semantic-interposition"
PYTHON_LDFLAGS="${LDFLAGS_BASE} -fno-semantic-interposition"

# =============================================================================
# Environment Export
# =============================================================================

export_perf_flags() {
    export CFLAGS="${CFLAGS_PERF}"
    export CXXFLAGS="${CXXFLAGS_PERF}"
    export LDFLAGS="${LDFLAGS_PERF}"
    export MAKEFLAGS="-j${NPROC}"
}

export_safe_flags() {
    export CFLAGS="${CFLAGS_SAFE}"
    export CXXFLAGS="${CXXFLAGS_SAFE}"
    export LDFLAGS="${LDFLAGS_PERF}"
    export MAKEFLAGS="-j${NPROC}"
}

export_bootstrap_flags() {
    export CFLAGS="${CFLAGS_BOOTSTRAP}"
    export CXXFLAGS="${CXXFLAGS_BOOTSTRAP}"
    export LDFLAGS="${LDFLAGS_BASE}"
    export MAKEFLAGS="-j${NPROC}"
}

# =============================================================================
# Build System Detection
# =============================================================================

# Prefer mold for faster builds (runtime unaffected)
detect_linker() {
    if command -v mold >/dev/null 2>&1; then
        echo "-fuse-ld=mold"
    elif command -v ld.lld >/dev/null 2>&1; then
        echo "-fuse-ld=lld"
    else
        echo ""
    fi
}

LINKER_FLAG=$(detect_linker)
if [ -n "${LINKER_FLAG}" ]; then
    LDFLAGS_PERF="${LDFLAGS_PERF} ${LINKER_FLAG}"
fi
