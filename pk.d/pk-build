#!/bin/sh
# pk-build - build a package from package definitions
# Usage: pk build <pkgname>

SCRIPT_DIR="$(dirname "$0")"
. "$SCRIPT_DIR/pk-common"

[ $# -ge 1 ] || die "usage: pk build <pkgname>"

pkgname="$1"

# Get package metadata (using pk-common functions)
version=$(get_pkg_version "$pkgname")
[ -n "$version" ] || die "package '$pkgname' not found"

url=$(extract_field "$pkgname" "url")
build_system=$(extract_field "$pkgname" "build_system")
configure_flags=$(extract_field "$pkgname" "configure_flags")
meson_flags=$(extract_field "$pkgname" "meson_flags")
cmake_flags=$(extract_field "$pkgname" "cmake_flags")
source_pkg=$(extract_field "$pkgname" "source_pkg")

info "building $pkgname $version"

# Expand variables in version
version_mm=$(echo "$version" | sed 's/\.[^.]*$//')

# Find source directory
skip_extract=$(extract_field "$pkgname" "skip_extract")
source_dir=$(extract_field "$pkgname" "source_dir")
if [ -n "$source_dir" ]; then
    # Expand ${version} in source_dir
    source_dir=$(echo "$source_dir" | sed "s|\${version}|$version|g")
    srcdir="$SOURCES_DIR/$source_dir"
elif [ -n "$source_pkg" ]; then
    src_version=$(extract_field "$source_pkg" "version")
    srcdir="$SOURCES_DIR/${source_pkg}-${src_version}"
else
    srcdir="$SOURCES_DIR/${pkgname}-${version}"
fi

# For packages with skip_extract (like .run installers), don't require srcdir to exist
if [ "$skip_extract" = "true" ]; then
    # Clean any previous extraction
    rm -rf "$srcdir"
    builddir="$SOURCES_DIR/build-${pkgname}"
    pkgdir="$builddir/pkg"
    rm -rf "$builddir"
    mkdir -p "$pkgdir"
    cd "$SOURCES_DIR"
else
    [ -d "$srcdir" ] || die "source directory not found: $srcdir"
    builddir="$srcdir/build-pk"
    pkgdir="$builddir/pkg"
    rm -rf "$builddir"
    mkdir -p "$pkgdir"
    cd "$srcdir"
fi

export NPROC=$(nproc)
export PKG="$pkgdir"
export SOURCES_DIR
export version version_mm srcdir pkgdir

# Load optimization flags (unless skip_optimization is set)
skip_opt=$(extract_field "$pkgname" "skip_optimization")
if [ "$skip_opt" = "true" ]; then
    # Package manages its own optimization (e.g. GCC bootstrap)
    export CFLAGS="-O2 -march=znver3"
    export CXXFLAGS="$CFLAGS"
    export LDFLAGS=""
    export FFLAGS="$CFLAGS"
    export FCFLAGS="$CFLAGS"
    info "skip_optimization: using minimal flags"
else
    BUILD_CONF=""
    for f in "./config/build.conf" "$SCRIPT_DIR/../config/build.conf" "/etc/pk/build.conf"; do
        [ -f "$f" ] && BUILD_CONF="$f" && break
    done
    if [ -n "$BUILD_CONF" ]; then
        . "$BUILD_CONF"
        # Use LTO flags for native builds
        export CFLAGS="${CFLAGS_LTO:-$CFLAGS_PERF}"
        export CXXFLAGS="${CXXFLAGS_LTO:-$CFLAGS_PERF}"
        export LDFLAGS="${LDFLAGS_LTO:-$LDFLAGS}"
        export FFLAGS="$CFLAGS"
        export FCFLAGS="$CFLAGS"
        info "using optimization flags from $BUILD_CONF"
    else
        # Fallback Zen 3 flags
        export CFLAGS="-O3 -march=znver3 -mtune=znver3 -pipe -flto=$NPROC"
        export CXXFLAGS="$CFLAGS"
        export LDFLAGS="-Wl,-O2 -Wl,--as-needed -flto=$NPROC"
        export FFLAGS="$CFLAGS"
        export FCFLAGS="$CFLAGS"
    fi
fi

# If using LTO, use gcc-ar/gcc-ranlib/gcc-nm for proper LTO object handling
# This ensures ar/ranlib/nm can process LTO bytecode even if build systems
# don't respect the bfd-plugins symlink
if echo "$CFLAGS" | grep -q '\-flto'; then
    export AR=gcc-ar
    export RANLIB=gcc-ranlib
    export NM=gcc-nm
    info "LTO enabled: using gcc-ar/gcc-ranlib/gcc-nm"
fi

export MAKEFLAGS="-j$NPROC"

# Get build commands
build_commands=$(extract_array "$pkgname" "build_commands")

build_failed=0

# Redirect all build output to stderr so only the final archive path goes to stdout
exec 3>&1  # save original stdout
exec 1>&2  # redirect stdout to stderr for build commands

if [ -n "$build_commands" ]; then
    # Custom build commands - use temp file to avoid subshell issue with pipe
    tmpfile=$(mktemp)
    echo "$build_commands" > "$tmpfile"
    while IFS= read -r cmd; do
        [ -n "$cmd" ] || continue
        cmd=$(echo "$cmd" | sed "s|\${version}|$version|g; s|\${version_mm}|$version_mm|g; s|\${srcdir}|$srcdir|g; s|\${pkgdir}|$pkgdir|g; s|\${PKG}|$pkgdir|g; s|\${NPROC}|$NPROC|g")
        info "running: $cmd"
        if ! eval "$cmd"; then
            warn "build command failed: $cmd"
            build_failed=1
            break
        fi
    done < "$tmpfile"
    rm -f "$tmpfile"
elif [ "$build_system" = "meson" ]; then
    meson setup "$builddir/meson" --prefix=/usr --libdir=lib $meson_flags || build_failed=1
    [ $build_failed -eq 0 ] && { ninja -C "$builddir/meson" || build_failed=1; }
    [ $build_failed -eq 0 ] && { DESTDIR="$pkgdir" ninja -C "$builddir/meson" install || build_failed=1; }
elif [ "$build_system" = "cmake" ]; then
    mkdir -p "$builddir/cmake"
    cd "$builddir/cmake"
    cmake "$srcdir" -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_INSTALL_LIBDIR=lib $cmake_flags || build_failed=1
    [ $build_failed -eq 0 ] && { make -j$NPROC || build_failed=1; }
    [ $build_failed -eq 0 ] && { make DESTDIR="$pkgdir" install || build_failed=1; }
elif [ "$build_system" = "autotools" ] || [ -x "$srcdir/configure" ]; then
    ./configure --prefix=/usr $configure_flags || build_failed=1
    [ $build_failed -eq 0 ] && { make -j$NPROC || build_failed=1; }
    [ $build_failed -eq 0 ] && { make DESTDIR="$pkgdir" install || build_failed=1; }
elif [ -f "$srcdir/Makefile" ]; then
    make -j$NPROC prefix=/usr || build_failed=1
    [ $build_failed -eq 0 ] && { make DESTDIR="$pkgdir" prefix=/usr install || build_failed=1; }
else
    die "unknown build system for $pkgname"
fi

exec 1>&3  # restore stdout
exec 3>&-  # close fd 3

# Check for build failure or empty package
if [ $build_failed -ne 0 ]; then
    die "build failed for $pkgname"
fi

# Count files in pkgdir (excluding just the root directory)
file_count=$(find "$pkgdir" -type f | wc -l)
if [ "$file_count" -eq 0 ]; then
    die "build produced empty package for $pkgname (no files installed)"
fi

# Create package
mkdir -p "$CACHE_DIR"
pkg_archive="$CACHE_DIR/${pkgname}-${version}.pk.tar.xz"
cd "$pkgdir"
# Ensure pkgdir root has sane permissions (prevents installing bad perms to /)
chmod 755 "$pkgdir"
tar cJf "$pkg_archive" .

info "created $pkg_archive"
echo "$pkg_archive"
