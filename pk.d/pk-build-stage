#!/bin/sh
# pk-build-stage - build all packages in a stage
# Usage: pk build-stage <stage_number>

SCRIPT_DIR="$(dirname "$0")"
. "$SCRIPT_DIR/pk-common"

[ $# -ge 1 ] || die "usage: pk build-stage <stage_number>"

stage="$1"

# Initialize packages directory (from pk-common)
find_packages_dir

info "building stage $stage packages"

# Extract packages for this stage, sorted by build_order
packages=$(cat_packages | awk -v stage="$stage" '
    /^\[packages\./ {
        pkg = $0
        gsub(/\[packages\.|\]/, "", pkg)
        current_pkg = pkg
        pkg_stage = ""
        build_order = 999
    }
    /^stage *= *[0-9]/ {
        gsub(/stage *= */, "")
        pkg_stage = $0 + 0
    }
    /^build_order *= *[0-9]/ {
        gsub(/build_order *= */, "")
        build_order = $0 + 0
    }
    /^\[/ && current_pkg != "" && pkg_stage == stage {
        print build_order, current_pkg
        current_pkg = ""
    }
    END { if (current_pkg != "" && pkg_stage == stage) print build_order, current_pkg }
' | sort -n | awk '{print $2}')

if [ -z "$packages" ]; then
    die "no packages found for stage $stage"
fi

count=$(echo "$packages" | wc -l)
info "found $count packages for stage $stage"

failed=""
i=0
for pkg in $packages; do
    i=$((i + 1))
    info "[$i/$count] building $pkg"

    # Check if already installed
    if [ -d "$DB_DIR/$pkg" ]; then
        info "$pkg already installed, skipping"
        continue
    fi

    # Download source
    "$SCRIPT_DIR/pk-download" "$pkg" || { warn "download failed: $pkg"; failed="$failed $pkg"; continue; }

    # Build package
    pkg_file=$("$SCRIPT_DIR/pk-build" "$pkg") || { warn "build failed: $pkg"; failed="$failed $pkg"; continue; }

    # Install package
    "$SCRIPT_DIR/pk-install" "$pkg_file" || { warn "install failed: $pkg"; failed="$failed $pkg"; continue; }

    info "$pkg completed"
done

if [ -n "$failed" ]; then
    warn "failed packages:$failed"
    exit 1
fi

info "stage $stage complete"
