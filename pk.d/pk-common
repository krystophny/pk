#!/bin/sh
# pk-common - shared functions for pk package manager
# Sourced by pk subcommands

VERSION="0.0.2"

# Paths - PK_ROOT must end with / (or be empty for local/safe mode)
# If PK_ROOT is unset/empty, paths are relative (safe, installs locally)
# If PK_ROOT="/", paths are absolute (system install)
# If PK_ROOT="/mnt/lfs/", paths go to chroot
case "$PK_ROOT" in
    "") ;; # empty is fine (relative paths)
    */) ;; # ends with slash is fine
    *)  PK_ROOT="${PK_ROOT}/" ;; # add trailing slash
esac
DB_DIR="${PK_ROOT}var/lib/pk"
CACHE_DIR="${PK_ROOT}var/cache/pk"
SOURCES_DIR="${PK_ROOT}usr/src"

die() { echo "pk: $*" >&2; exit 1; }
warn() { echo "pk: warning: $*" >&2; }
info() { echo "pk: $*"; }

# Safety check - warn if PK_ROOT is empty (relative/local mode)
safety_check() {
    if [ -z "$PK_ROOT" ]; then
        warn "PK_ROOT is empty - using relative paths (local mode)"
        warn "Set PK_ROOT=/ for system install or PK_ROOT=/mnt/lfs/ for chroot"
    fi
}

# Parse package name and version from filename
# foo-1.2.3.pkg.tar.xz -> name=foo version=1.2.3
parse_pkgname() {
    local basename="${1##*/}"
    basename="${basename%.pkg.tar*}"
    basename="${basename%.tar*}"

    local name="" version="" char="" rest=""
    rest="$basename"
    while [ -n "$rest" ]; do
        char="${rest%"${rest#?}"}"
        rest="${rest#?}"
        if [ "$char" = "-" ]; then
            next="${rest%"${rest#?}"}"
            case "$next" in
                [0-9])
                    version="$rest"
                    break
                    ;;
            esac
        fi
        name="${name}${char}"
    done

    [ -z "$name" ] && name="$basename"
    [ -z "$version" ] && version="unknown"

    echo "$name" "$version"
}

# Get all tracked files (with symlink-aware paths)
get_tracked_files() {
    cat "$DB_DIR"/*/files 2>/dev/null | \
        sed 's|^\./|/|' | \
        sed 's|^/bin/|/usr/bin/|; s|^/sbin/|/usr/sbin/|; s|^/lib/|/usr/lib/|' | \
        grep -v '^/$' | sort -u
}
